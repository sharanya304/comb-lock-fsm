# Combination Lock FSM 

A clean, synthesizable Verilog implementation of a combination-lock finite state machine (FSM) with a small change-password flow and comprehensive simulation tests.

This repository is designed to be interview-ready: it documents architecture and design choices, contains simulation artifacts for quick verification, and is structured to make both synthesis and test automation straightforward.


## Table of contents
- Project summary
- Architecture & data flow
- How to run (simulation + quick checks)
- Design decisions & trade-offs
- Testing strategy


## Project summary
This project implements a 4-digit combination lock with the following behavior:
- Accepts one BCD digit per clock on `ip_pass[3:0]`.
- User presses `enter_button` to begin a 4-digit entry sequence.
- A correct 4-digit code produces `grant=1` for one cycle (Moore-style outputs).
- Three consecutive wrong attempts result in `LOCK=1` for a timeout period; after the timeout, attempts reset.
- A simplified `change_password` module demonstrates a verification-and-update flow for the stored password.

The code targets both simulation (XSim/Vivado) and synthesis (Vivado/Yosys).



## Architecture & data flow
- The FSM is implemented in `src/comb_lock.v` as a Moore machine with 3-bit state encoding (IDLE, CHECK_1..4, GRANT, DENY, LOCK).
- The stored password is an array `stored_pass[3:0]` that lives in `top_comblock` and is wired into `comb_lock` and `change_password`. This separates storage from verification logic and allows testbenches or top-level integrators to manage passwords.
- `change_password` is an auxiliary FSM that demonstrates a simple verification (old digit match) and new-password update path; `top_comblock` switches the active outputs between verification and change modes.

Data flows:
- User input (`ip_pass`) presented 1-clock-per-digit.
- `enter_button` signals the start of a code entry.
- `comb_lock` steps through CHECK_1..4 states sampling `ip_pass` each clock.
- `attempt_count` increments on DENY; when it reaches 3 (third DENY) the machine enters LOCK and a timeout timer prevents immediate retries.


## How to run (simulation)
Recommended: use Vivado / xsim or your preferred Verilog simulator. The repository ships with prebuilt xsim scripts.

Notes:
- The testbenches set a short SIM timeout for fast runs; modify the `SIM_TIMEOUT_CYCLES` constant in TBs or `top_comblock.v` to change behavior for longer simulations.
- Use `src/tb_comb_lock.v` for a task-free inline TB (portable across toolchains that restrict TB constructs).
- Waveforms generated by XSim are available under `comb_lock_fsm.sim/sim_1/behav/xsim/` — open `.wdb` or `.vcd` files with Vivado/XSim waveform viewers.


## Design decisions & trade-offs
- Stored-pass as external array: Keeps the verification FSM pure and testable. `top_comblock` manages storage and updates, simplifying unit tests for `comb_lock`.
- Moore outputs: `grant`, `deny`, and `lock` are driven from state only; this keeps timing simpler and avoids glitches in combinational outputs.
- Simplified change-password flow: `change_password` demonstrates the concept with a small state machine; a production-ready flow would include multi-digit verification, authentication, and secure storage.
- Testbench styles: The repo contains both task-based and task-free testbenches. Tasks are more readable for complex sequences; the inline TB is included for environments or reviewers that prefer or require no tasks.


## Testing strategy
- Unit behavior is verified with simulation TBs in `comb_lock_fsm.srcs/sim_1/new/tb.v` (task-based) and `src/tb_comb_lock.v` (inline). Both cover:
	- Correct code → GRANT
	- Wrong attempts → DENY
	- 3rd wrong attempt → LOCK, then timeout → unlock
	- Basic change-password update and verification
- Extend with regression tests by adding additional TBs or automating runs in CI that call the xsim scripts and assert pass/fail based on stderr/console output.



